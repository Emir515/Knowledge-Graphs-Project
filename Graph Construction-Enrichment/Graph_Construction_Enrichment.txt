Knowledge Graph: Travel Data (Neo4j Aura)

This workflow builds a **knowledge graph** of European travel patterns using **Eurostat tourism datasets**.  
We focus on **Trips**, their **Destinations**, and traveler attributes (**Age**, **Sex**).  

--------------------------------------------------------------------------------
Datasets
--------------------------------------------------------------------------------
- extot_ready.csv → Trips + Destinations  
- tnage_ready.csv → Age groups  
- ttsex_ready.csv → Sex groups  

The datasets firstly preprocessed to make it ready for the Neo4J to create the knowledge graph,
and they were uploaded to a Github repository to make them easy to access by Neo4j Aura, the preprocess 
steps can be found in the Preprocessing.ipynb file, in this file first we checked the datasets and the 
columns that we are going to use the graph, the I created the preprocess function in this file to make 
the process more stable for all the three datasets. And then the datasets were saved in local, commited to the repository
that you can find below:

All datasets are available in the GitHub repository under:
https://github.com/Emir515/Knowledge-Graphs-Project/tree/main/Datasets/Processed

--------------------------------------------------------------------------------
Setup in Neo4j Aura
--------------------------------------------------------------------------------

----Import Destinations-----
----------------------------
CALL {
  LOAD CSV WITH HEADERS
  FROM "https://raw.githubusercontent.com/Emir515/Knowledge-Graphs-Project/main/Datasets/processed/extot_clean.csv"
  AS row
  WITH row
  WHERE row.`geo\time_period` IS NOT NULL AND row.c_dest IS NOT NULL
  MERGE (d:Destination {geo: row.`geo\time_period`, c_dest: row.c_dest})
}
IN TRANSACTIONS OF 1000 ROWS
RETURN count(*);


----Import Trips (link to Destinations)-----
--------------------------------------------
CALL {
  LOAD CSV WITH HEADERS
  FROM "https://raw.githubusercontent.com/Emir515/Knowledge-Graphs-Project/main/Datasets/processed/extot_clean.csv"
  AS row
  WITH row
  WHERE row.`geo\time_period` IS NOT NULL AND row.year IS NOT NULL
  MERGE (t:Trip {
      trip_id: row.`geo\time_period` + "_" + row.year + "_" + row.purpose + "_" + row.duration + "_" + row.freq
  })
  SET t.year = toInteger(row.year),
      t.purpose = row.purpose,
      t.duration = row.duration,
      t.freq = row.freq,
      t.unit = row.unit
  WITH t, row
  MATCH (d:Destination {geo: row.`geo\time_period`, c_dest: row.c_dest})
  MERGE (t)-[:TO_DESTINATION]->(d)
}
IN TRANSACTIONS OF 1000 ROWS
RETURN count(*);


----Import Expenditures (link to Trips)----
CALL {
  LOAD CSV WITH HEADERS
  FROM "https://raw.githubusercontent.com/Emir515/Knowledge-Graphs-Project/main/Datasets/processed/extot_clean.csv"
  AS row
  WITH row, trim(row.year) AS cleanYear
  WHERE row.value IS NOT NULL AND row.value <> ''
  // Build trip_id with the same "year + space" format
  WITH row, cleanYear, row.`geo\time_period` + "_" + cleanYear + " _" + row.purpose + "_" + row.duration + "_" + row.freq AS tripKey
  MATCH (t:Trip {trip_id: tripKey})
  MERGE (e:Expenditure {expend: row.expend, statinfo: row.statinfo})
  SET e.value = toFloat(row.value)
  MERGE (t)-[:HAS_EXPENDITURE]->(e)
}
IN TRANSACTIONS OF 1000 ROWS
RETURN count(*);




-----Import TravellerSex (link to Trips)----
--------------------------------------------
CALL {
  LOAD CSV WITH HEADERS
  FROM "https://raw.githubusercontent.com/Emir515/Knowledge-Graphs-Project/main/Datasets/processed/ttsex_clean.csv"
  AS row
  WITH row, trim(row.year) AS cleanYear
  WHERE row.sex IS NOT NULL AND row.value IS NOT NULL AND row.value <> ''
  WITH row, cleanYear, row.`geo\time_period` + "_" + cleanYear + " _" + row.purpose + "_" + row.duration + "_" + row.freq AS tripKey
  MERGE (s:TravellerSex {sex: row.sex})
  WITH s, row, tripKey
  MATCH (t:Trip {trip_id: tripKey})
  MERGE (s)-[:TOOK_TRIP {count: toFloat(row.value)}]->(t)
}
IN TRANSACTIONS OF 1000 ROWS
RETURN count(*);



----Import TravellerAge (link to Trips)-----
------------------------------------------
CALL {
  LOAD CSV WITH HEADERS
  FROM "https://raw.githubusercontent.com/Emir515/Knowledge-Graphs-Project/main/Datasets/processed/tnage_clean.csv"
  AS row
  WITH row, trim(row.year) AS cleanYear
  WHERE row.age IS NOT NULL AND row.value IS NOT NULL AND row.value <> ''
  WITH row, cleanYear, row.`geo\time_period` + "_" + cleanYear + " _" + row.purpose + "_" + row.duration + "_" + row.freq AS tripKey
  MERGE (a:TravellerAge {age: row.age})
  WITH a, row, tripKey
  MATCH (t:Trip {trip_id: tripKey})
  MERGE (a)-[:TOOK_TRIP {count: toFloat(row.value)}]->(t)
}
IN TRANSACTIONS OF 1000 ROWS
RETURN count(*);




----------
CALL {
  LOAD CSV WITH HEADERS
  FROM "https://raw.githubusercontent.com/Emir515/Knowledge-Graphs-Project/main/Datasets/processed/extot_clean.csv"
  AS row
  WITH row
  WHERE row.expenditure_value IS NOT NULL AND row.expenditure_value <> ''
  MATCH (t:Trip {
      trip_id: row.`geo\time_period` + "_" + row.year + "_" + row.purpose + "_" + row.duration + "_" + row.freq
  })
  MERGE (e:Expenditure {expend: row.expend, statinfo: row.statinfo})
  SET e.value = toFloat(row.expenditure_value)
  MERGE (t)-[:HAS_EXPENDITURE]->(e)
}
IN TRANSACTIONS OF 1000 ROWS
RETURN count(*);




----Data Verify-------
// Count nodes by label
MATCH (n) RETURN labels(n), count(*);

// Count relationships by type
MATCH ()-[r]->() RETURN type(r), count(*);

// Preview part of the graph
MATCH (t:Trip)-[r]->(d:Destination)
RETURN t, r, d LIMIT 10;




----Graph Enrichment----
UNWIND [
  {code:'PER', label:'Personal'},
  {code:'BUS', label:'Business'}
] AS purpose
MERGE (p:Purpose {code: purpose.code})
SET p.label = purpose.label;

MATCH (t:Trip)
MERGE (p:Purpose {code: t.purpose})
MERGE (t)-[:HAS_PURPOSE]->(p);



------------
UNWIND [
  {code:'ACCOM', label:'Accommodation'},
  {code:'TRANSP', label:'Transport'},
  {code:'FOOD', label:'Food & Beverage'},
  {code:'TOTAL', label:'Total'}
] AS expend
MERGE (e:ExpenditureCategory {code: expend.code})
SET e.label = expend.label;

MATCH (exp:Expenditure)
MERGE (cat:ExpenditureCategory {code: exp.expend})
MERGE (exp)-[:BELONGS_TO]->(cat);


------------
MATCH (t:Trip)
MERGE (y:Year {value: t.year})
MERGE (t)-[:IN_YEAR]->(y);













